#!/bin/bash
#
# changelog
#  2021-05-22  :: Created
#
#───────────────────────────────( requirements )────────────────────────────────
# Database file stored at ${XDG_CONFIG_HOME:-${HOME}/.config}/hre-utils/conf/
# Contains mapping of a friendly name (or names?) to a file path. Maybe it would
# be helpful to specify the resulting file path as the first column, then all
# associated names for it as the subsequent columns. Hmm. Or a tagging system
# for searching as well.
#     PATH  name1,name2,name3  tag1:tag2:tag2
# Can search by name or tag with:
#     [[ :"$2": == *:$tag:* ]]
# Alternatively with `awk`
#     $ awk "\$2 ~ /(^|,)($word)(\$|,)/ {print \$1}"
# I think awk is a better choice here. While we can do this loop with only bash
# builtins, the single call to `awk` won't impact performance drastically.
#
# Validation. Example, ensure the user has not passed 'name1,name2,'. We may
# be able to correct these in-place, and warn the user. Draft out effectively a
# specsheet detailing the allowed components of each part. Huh, this is starting
# to sound like good use of practicing some mad basic EBNF. Still haven't played
# arround with it.
#
# In-place format options
#  1. Sort
#  2. Columnize
#
#══════════════════════════════════╡ GLOBAL ╞═══════════════════════════════════
PROGDIR=$( cd "$(dirname "${BASH_SOURCE[0]}")" ; pwd )

#CONFDIR="${XDG_CONFIG_HOME:-$HOME/.config}/hre-utils/conf"
CONFDIR="${PROGDIR}/tmp_data"
mkdir -p "$CONFDIR"

DATABASE="${CONFDIR}/database"
CONFFILE="${CONFDIR}/config"

#──────────────────────────────────( source )───────────────────────────────────
# TODO: use `import.sh`
source $(which mk-colors.sh)
source "${CONFFILE}"

#═════════════════════════════════╡ FUNCTIONS ╞═════════════════════════════════
#───────────────────────────────────( utils )───────────────────────────────────
function usage {
cat <<EOF
USAGE: ./$(basename "${BASH_SOURCE[0]}") [OPTION] (COMMAND | NAME)

Options:
   -a | --add PATH         Creates new database entry for PATH, idenfied as NAME

   -t | --tag TAG[:TAG]    Add tag(s) to database entry for sorting or filtering

   -d | --debug LOW[,HIGH] Sets debug level to filter unncessary output messages
                           NOTE: Defaults LOW to 2 (WARN), levels <0 are garbage

Commands:
   --ls                    Lists all entries in the database, columnizing output

   --tls TAG               Search in database for entries matching specified TAG

   --column                In-place modifies database file to even width columns

   --sort NUM[,NUM]        In-place sorts database file by the specified col NUM

   --edit (db|conf)        Opens \`conf\`s own confuration file for manual editing
                           NOTE: As this is a manual action, it does not trigger
                           any auto_ features, such as auto_sort or auto_column.
EOF

exit $1
}


function write {
   local lvl=$1 text="$2"

   local debug_level=${__debug_level__:-$debug_level}
   read low high __ <<< ${debug_level//,/ }
   low=${low:-2} ; high=${high:-3}

   [[ $lvl -lt $low  ]] && return 0
   [[ $lvl -gt $high ]] && return 0

   local lvlname color
   case $lvl in
     -2) color="${bk}"  ; lvlname='TRASH' ;;
     -1) color="${bk}"  ; lvlname='NOISE' ;;
      0) color="${cy}"  ; lvlname='DEBUG' ;;
      1) color="${wh}"  ; lvlname='INFO'  ;;    # <- default user-visible from
      2) color="${yl}"  ; lvlname='WARN'  ;;    #    here down
      3) color="${brd}" ; lvlname='CRIT'  ;;

      *) color="${wh}"  ; lvlname='INFO'  ;;
   esac

   #printf "${color}[%-5s] %s${rst}\n"  "$lvlname"  "$text"
   echo "${color}[$lvlname] ${text}${rst}"
}


function get_editor {
   if [[ -n $editor ]] ; then
      echo "$editor"
   elif [[ -n $EDITOR ]] ; then
      echo "$EDITOR"
   elif [[ $(which vim 2>/dev/null) ]] ; then
      echo 'vim'
   elif [[ $(which emacs 2>/dev/null) ]] ; then
      echo 'emacs'
   fi
}


function do_auto_column {
   local columned=$( column -t "$DATABASE" )
   echo "$columned" > "$DATABASE"
}


function do_auto_sort {
   local col=${1:-$auto_sort}

   if [[ ! $col =~ ^[[:digit:]](,[[:digit:]])?$ ]] ; then
      write 2 "Invalid --sort param ($col)"
      col=2
   fi

   local sorted=$( sort -k "$col" "$DATABASE" )
   echo "$sorted" > "$DATABASE"
}


function list_by_tag {
   local search="$1"

   column -t < <(
      awk "\$3 ~ /(^|:)($search)(\$|:)/ {print \$1 \" \" \$2}"  "${DATABASE}"
   )
}


function edit_internal {
   case $1 in
      d|db|data|database)
            file="${DATABASE}"
            ;;

      c|conf|config)
            file="${CONFFILE}"
            ;;

      *)    write 2 "Invalid param for --edit ($1). Defaulting to 'database'"
            file="${DATABASE}" ;;
   esac

   exec $editor $file
}


function edit_file {
   local name=$__name__
   local path=$(
      awk "\$2 ~ /(^|,)($name)(\$|,)/ {print \$1}"  "${DATABASE}"
   )

   if [[ -z $path ]] ; then
      write 3 "No entry found matching '$name'"
      exit 1
   fi

   if [[ $(wc -l <<< "$path") -gt 1 ]] ; then
      write 3 "Multiple files with the same NAME ($name) found"
      exit 2
   fi

   exec $editor $path
}


function apply_tag {
   local name=$__name__
   local path=$(
      awk "\$2 ~ /(^|,)($name)(\$|,)/ {print \$1}"  "${DATABASE}"
   )

   if [[ -z $path ]] ; then
      write 3 "No entry found matching '$name'"
      exit 1
   fi

   if [[ $(wc -l <<< "$path") -gt 1 ]] ; then
      write 3 "Multiple files with the same NAME ($name) found"
      exit 2
   fi

   awk "\$2 ~ /(^|,)($name)(\$|,)/ {print \$1}"  "${DATABASE}"
}


function add_entry {
   echo "$__path__ $__name__" >> "${DATABASE}"
   [[ $auto_column =~ ([Yy]es|[Tt]rue)  ]] && do_auto_column
   [[ ! $auto_sort =~ (|[Nn]o|[Ff]alse) ]] && do_auto_sort
}

#══════════════════════════════════╡ ENGAGE ╞═══════════════════════════════════
[[ $# -eq 0 ]] && usage 1

editor=$( get_editor )
if [[ -z $editor ]] ; then
   write 3 "Editor is unset, specify in config file."
   exit 1
fi

#─────────────────────────────────( argparse )──────────────────────────────────
# Defaults
__add__=false
__tag__=false

while [[ $# -gt 0 ]] ; do
   case $1 in
      -h|--help)
            usage 0 ;;

      # Options:
      -d|--debug)
            shift ; __debug_level__="$1"
            shift ;;

      -a|--add)
            __add__=true
            shift ; __path__="$1"
            shift ;;

      -t|--tag)
            __tag__=true
            shift ; __tags__="$1"
            shift ;;

      # Commands:
      --edit)
            shift ; edit_internal "$1" ;;

      --column)
            do_auto_column
            exit 0 ;;

      --sort)
            shift
            do_auto_sort ${1:-2}
            exit 0 ;;

      --ls)
            cat "${DATABASE}"
            exit 0 ;;

      --lst)
            shift
            list_by_tag "$1"
            exit 0 ;;

      # Defaults:
      -*) __invalid__+=( $1 ) ; shift ;;

      *) __positional__+=( "$1" ) ; shift ;;
   esac
done

# Validation
declare -a ERRORS_ARGPARSE

if [[ ${#__positional__[@]} -ne 1 ]] ; then
   ERRORS_ARGPARSE+=( "NAME not specified" )
else
   __name__="${__positional__[0]}"
fi

if [[ ${#__invalid__[@]} -gt 0 ]] ; then
   ERRORS_ARGPARSE+=( "Invalid option(s): ${__invalid__[@]}" )
fi

if [[ ${#ERRORS_ARGPARSE[@]} -gt 0 ]] ; then
   write 3 "Errors in argument parsing"

   for idx in "${!ERRORS_ARGPARSE[@]}" ; do
      err="${ERRORS_ARGPARSE[$idx]}"
      echo "  $((idx+1)). $err"
   done

   exit 1
fi

#──────────────────────────────────( do shit )──────────────────────────────────
if $__add__ ; then
   add_entry
elif $__tag__ ; then
   apply_tag
else
   edit_file
fi
